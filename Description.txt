My project began with me defining the predicate jump_checker which allows me to read in 4 values (X1 & Y1, X2 & Y2) and checks the validity of the change in co-ordinates using the rule that: “A Knight can move 2 squares vertically and 1 square horizontally, or 2 squares horizontally and 1 square vertically.” For example, if the co-ordinates of the start space are 1/1, and the co-ordinates of the space in which the knight winds up are 3/2 it will return True as the knight has moved in a way which satisfies the rule defined above, likewise if given co-ordinates of 1/1 and 4/2 it will return False as these co-ordinates do not satisfy the predicate. valid_jump_checker is defined after this. This works in conjunction with jump_checker to ensure the values passed are valid within a chessboard by making sure the values are in the range 1 to 8. This can be tested by typing, for example: jump_checker(1/1, 2/3). This will return True. jump_checker(1/1, 3/3). will return False as it does not meet the requirements defined in the jump_checker predicate. jump_checker(9/9, 10/11). would also return False as although it is technically a valid movement in terms of the rules stated about legal moves, it is outside the range 1/1 – 8/8.

I then defined the knightpath predicate. This works by passing a list (Path) to the predicate and returning True if the Path of co-ordinates given are valid moves as defined by jump_checker. I used recursion in this case in order to iterate through the list, the base case checks just the second element in the list against the first element, the next case then iterates through the list while maintaining the process of checking the validity of moves. I tested this predicate by typing for example: knightpath(1/1, 2/3, 4/4, 5/6). this would return True as it meets the requirements as defined by jump_checker, likewise the predicate knightpath(1/1, 2/3, 4/5, 5/6). would return False as element 3 does not conform to the requirements.

knightjourney is the next predicate defined in my program. It reads in the starting element, last element, length of list Path and the list Path itself. It uses the start_element and end_element defined earlier in the program to ensure the two first parts read in are the beginning and finishing elements of the list Path. It then checks the length of list Path L (which is obtained using the inbuilt prolog operator length) and ensures the list Path consists of valid moves, this again uses the knightpath on the list Path. I checked this predicate by using multiple possible paths for example: knightjourney(1/1, 5/6, 4, [1/1, 2/3, 4/4, 5/6]). which returns True as it meets all the previously defined requirements stated above. I also did a number of tests such as: knightjourney(1/2, 5/6, 4, [1/1, 2/3, 4/4, 5/6]). which returns false as the starting element is not a member of the list. 

knightpassthru is the final predicate I have defined in my prolog program. In this case the list (Path) is read in first, followed by a variable Sq which represents the co-ordinates of a square within the list Path. Finally the variable N is read in which represents Sq’s place in the list Path. This works by using a checker I defined as position_check which recursively finds an elements place in the list provided to it and returns True if the element is present in the list and True if the position provided is correct . knightpassthru utilises this to ensure the element Sq in list Path is the Nth element of the list by returning True or False. 
In order to answer the question being put to us “Using the relations you have defined, is there a 4 move path for a knight from square 2/1 to the opposite side of the board that passes through the square 4/2 on the second move? What is that path?” I decided to use the knightjourney predicate in conjunction with the knightpassthru predicate, both of which I described earlier. knightjourney allows me to type the beginning of the Path (2/1) and the end of the path which can be any co-ordinate in the range 1/8 to 8/8 as this is the opposite side of the board(here I am assuming that the opposite side of the board is the top row as the beginning of the path is on the bottom row). The length of the Path, L (which is again obtained using the inbuilt prolog operator length) is then passed which must be 5. This is because we must include the starting element in the list of elements (Path). Despite containing 5 elements within the list, 4 moves are actually occurring. Finally the list Path is passed in. knightpassthru allows me to ensure the second element in the list Path is always 4/2 also.
						In order to discern if there is valid path that includes 4/2 as the second element I queried the knightjourney and knightpassthru predicate in the following way:   knightjourney(2/1, _/8, 5, X), knightpassthru(X, 4/2, 2). 

The possible paths are as follows: 
•	List = [2/1, 4/2, 3/4, 2/6, 1/8] 
•	List = [2/1, 4/2, 3/4, 2/6, 3/8] 
•	List = [2/1, 4/2, 3/4, 4/6, 3/8] 
•	List = [2/1, 4/2, 3/4, 4/6, 5/8] 
•	List = [2/1, 4/2, 5/4, 4/6, 3/8] 
•	List = [2/1, 4/2, 5/4, 4/6, 5/8] 
•	List = [2/1, 4/2, 5/4, 6/6, 5/8] 
•	List = [2/1, 4/2, 5/4, 6/6, 7/8] 
